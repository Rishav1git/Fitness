{"mappings":"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","sources":["js/script.js"],"sourcesContent":["// HTML elements\r\nconst videoElement = document.getElementById('webcam');\r\nconst canvasElement = document.getElementById('threeCanvas');\r\nconst gameOverText = document.getElementById('gameOver');\r\ncanvasElement.width = 640;\r\ncanvasElement.height = 480;\r\n\r\n// 3D scene setup\r\nconst scene = new THREE.Scene();\r\nconst camera = new THREE.PerspectiveCamera(75, canvasElement.width / canvasElement.height, 0.1, 1000);\r\nconst renderer = new THREE.WebGLRenderer({ canvas: canvasElement, alpha: true });\r\nrenderer.setSize(canvasElement.width, canvasElement.height);\r\ncamera.position.z = 5;\r\n\r\n// Player and obstacle objects\r\nconst playerBox = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));\r\nscene.add(playerBox);\r\n\r\nlet obstacles = [];\r\nconst obstacleSpeed = 0.05;\r\nlet squatDetected = false, jumpDetected = false, lungeDetected = false;\r\nlet isGameOver = false;\r\n\r\n// Function to create obstacles\r\nfunction createObstacle() {\r\n    const obstacleGeometry = new THREE.SphereGeometry(0.3, 32, 32);\r\n    const obstacleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });\r\n    const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);\r\n    obstacle.position.set((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, camera.position.z - 10);\r\n    obstacles.push(obstacle);\r\n    scene.add(obstacle);\r\n}\r\n\r\n// Load PoseNet model and initialize webcam\r\nasync function setupCameraAndModel() {\r\n    const net = await posenet.load();\r\n    const stream = await navigator.mediaDevices.getUserMedia({ video: true });\r\n    videoElement.srcObject = stream;\r\n\r\n    // Start detecting poses and moving obstacles\r\n    detectPoses(net);\r\n    setInterval(createObstacle, 2000);  // Spawn obstacle every 2 seconds\r\n}\r\n\r\n// Pose detection and movement tracking\r\nasync function detectPoses(net) {\r\n    videoElement.onloadeddata = async () => {\r\n        while (!isGameOver) {\r\n            const pose = await net.estimateSinglePose(videoElement, { flipHorizontal: false });\r\n            if (pose.score > 0.5) trackMovement(pose);\r\n            updateObstacles();\r\n            detectCollisions();\r\n            render();\r\n            await tf.nextFrame();\r\n        }\r\n    };\r\n}\r\n\r\n// Track movements for avoiding obstacles\r\nfunction trackMovement(pose) {\r\n    const leftKnee = pose.keypoints.find(k => k.part === 'leftKnee');\r\n    const rightKnee = pose.keypoints.find(k => k.part === 'rightKnee');\r\n    const leftHip = pose.keypoints.find(k => k.part === 'leftHip');\r\n    const rightHip = pose.keypoints.find(k => k.part === 'rightHip');\r\n    const leftAnkle = pose.keypoints.find(k => k.part === 'leftAnkle');\r\n    const rightAnkle = pose.keypoints.find(k => k.part === 'rightAnkle');\r\n\r\n    if (leftKnee && rightKnee && leftHip && rightHip && leftAnkle && rightAnkle) {\r\n        const kneeY = (leftKnee.position.y + rightKnee.position.y) / 2;\r\n        const hipY = (leftHip.position.y + rightHip.position.y) / 2;\r\n        const ankleY = (leftAnkle.position.y + rightAnkle.position.y) / 2;\r\n\r\n        if (!squatDetected && hipY > kneeY + 50) {\r\n            squatDetected = true;\r\n            avoidObstacle(\"squat\");\r\n            setTimeout(() => { squatDetected = false; }, 2000); // Reset after 2 seconds\r\n        }\r\n        if (!jumpDetected && ankleY < kneeY - 30) {\r\n            jumpDetected = true;\r\n            avoidObstacle(\"jump\");\r\n            setTimeout(() => { jumpDetected = false; }, 2000); // Reset after 2 seconds\r\n        }\r\n        if (!lungeDetected && Math.abs(leftKnee.position.x - rightKnee.position.x) > 100) {\r\n            lungeDetected = true;\r\n            avoidObstacle(\"lunge\");\r\n            setTimeout(() => { lungeDetected = false; }, 2000); // Reset after 2 seconds\r\n        }\r\n    }\r\n}\r\n\r\n// Check if the movement avoids an obstacle\r\nfunction avoidObstacle(move) {\r\n    if (obstacles.length > 0) {\r\n        const nearestObstacle = obstacles[0];\r\n        if (move === \"jump\" && nearestObstacle.position.y < -0.5) {\r\n            console.log(\"Avoided obstacle by jumping!\");\r\n            removeObstacle(nearestObstacle);\r\n        } else if (move === \"squat\" && nearestObstacle.position.y > 0.5) {\r\n            console.log(\"Avoided obstacle by squatting!\");\r\n            removeObstacle(nearestObstacle);\r\n        } else if (move === \"lunge\") {\r\n            console.log(\"Avoided obstacle by lunging!\");\r\n            removeObstacle(nearestObstacle);\r\n        }\r\n    }\r\n}\r\n\r\n// Move obstacles towards the player and remove if passed\r\nfunction updateObstacles() {\r\n    obstacles.forEach(obstacle => {\r\n        obstacle.position.z += obstacleSpeed;\r\n    });\r\n    obstacles = obstacles.filter(obstacle => obstacle.position.z < camera.position.z);\r\n}\r\n\r\n// Detect collision with obstacles\r\nfunction detectCollisions() {\r\n    obstacles.forEach(obstacle => {\r\n        if (obstacle.position.distanceTo(playerBox.position) < 0.5) {\r\n            gameOver();\r\n        }\r\n    });\r\n}\r\n\r\n// Remove obstacle from scene and array\r\nfunction removeObstacle(obstacle) {\r\n    scene.remove(obstacle);\r\n    obstacles = obstacles.filter(obj => obj !== obstacle);\r\n}\r\n\r\n// End game\r\nfunction gameOver() {\r\n    isGameOver = true;\r\n    gameOverText.style.display = 'block';\r\n    console.log(\"Game Over!\");\r\n}\r\n\r\n// Render 3D scene\r\nfunction render() {\r\n    renderer.render(scene, camera);\r\n}\r\n\r\n// Initialize camera and model\r\nsetupCameraAndModel();\r\n"],"names":[],"version":3,"file":"index2.1c974c2f.js.map","sourceRoot":"/__parcel_source_root/"}